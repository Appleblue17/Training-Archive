## C. Epoch-making

### 题目描述

*The story of this problem is generated by a large language model. Any
resemblance to actual persons or events is purely coincidental.*

You've just joined a prestigious AI company that's totally not copying
other people's work. But internally, everyone knows: your team just
reverse-engineered some models of your competitor's, glued them
together, and launched them under your own logo.

It works...but it's **painfully slow**. The CTO is furious and wants it
to be faster --- now.

The model is composed of$\textstyle n$ tightly coupled components (clearly ripped from someone else's research,
so your team has no idea how to decouple them for optimization). These
components form a directed acyclic graph, representing computation
dependencies. Each component performs some computation and cannot begin
until *all* its required inputs are available --- that is, after its
preceding components have finished their computation.

Each component $\textstyle i$ takes $\textstyle w_i$ milliseconds to execute.
Once you start a component, it will finish in exactly $\textstyle w_i$ milliseconds.

To speed things up, your task is to organize the execution into
*batches*: at any point in time, you can execute *any non-empty set of
currently executable components in parallel*, as long as all their
dependencies have been satisfied. A component becomes executable once
all its preceding components have completed.

In each batch, you must compute all outputs of the selected components
before any downstream batch can start. Therefore, the batch latency is
determined by the *slowest* component in that batch.

Your goal is to schedule the computation in a way that respects all
dependencies and minimizes the total flow time, defined as the sum of
latencies of all executed batches.

### 输入描述

The first line contains two integers $\textstyle n$ and$\textstyle m$ ($\textstyle 1 \le n \le 24$, $\textstyle 0 \le m \le \binom{n}{2}$) ---
the number of components and the number of directed dependencies.

The second line contains$\textstyle n$ integers$\textstyle w_1, w_2, \dots, w_n$ ($\textstyle 1 \le w_i \le 10^6$) --- the
execution time of each component.

Each of the next $\textstyle m$ lines
contains two integers $\textstyle u$ and$\textstyle v$ ($\textstyle 1 \le u, v \le n, u \ne v$),
indicating that component $\textstyle u$'s
output is required as input by component $\textstyle v$. In other words, you must
finish computing $\textstyle u$ before
starting $\textstyle v$.

It is guaranteed that the dependency graph is acyclic with no duplicate
edges.

### 输出描述

Print a single integer --- the minimum possible total flow time, in
milliseconds.

### 示例1

#### 输入

```plain
5 4
3 1 4 1 5
1 3
2 3
3 4
3 5
```

#### 输出

```plain
12
```

### 示例2

#### 输入

```plain
3 1
1 4 5
1 3
```

#### 输出

```plain
6
```

### 备注

![](https://uploadfiles.nowcoder.com/images/20250724/0_1753355304383/88865CF0262E6F0811533E83AAD2264F)

